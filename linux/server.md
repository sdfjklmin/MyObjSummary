#### 基础单位
    一个位节存储 8 位无符号数，储存的数值范围为0-255。 2^8 - 1
    1B       = 8bit
    1bit     = 0.125B
    1 / 8    = 125
    以 `字节` 分割,向上 `1024`, 向下 `8`.
    
    单位:
        Bit                 ——  比特
        B(Byte)             ——  字节
        KB(Kilobyte)        ——  千字节
        MB(Megabyte)        ——  兆字节
        GB(Gigabyte)        ——  吉字节
        TB(Trillionbyte)    ——  太字节
        更多请自行查阅!
        
    换算:
        1B      8位(Bit)
        1KB     1024B 
        1MB     1024KB 
        1GB     1024MB 

#### 腾讯云 5M 云服务器
    实际下载:    
        5M 服务器实际下载为 640kb/s
        服务商用的是 bit(比特)
        而实际下载用的是 byte (字节)
        最大值预算,网络传输要经过各种路由节点,会有一定的损失
        5Mbps = 640k byte/s ≈ 600k byte/s
        1M bit/s = 1024K bit/s = (1024/8) = 128k byte/s
        5M bit/s = 128k byte/s * 5 = 640k byte/s
        如果一个页面访问为 500ms 10kb,那么 1s 请求为 2个 10kb,即 1s = 20Kb 2个请求
        640 / 20 * 2 = 64 个用户同时访问  
    
    实际上传:
        5M 腾讯服务器实际上传为 1.25M/S
        腾讯以 10M 为分割, 小于 10M 按照 10M 算, 大于 10M 按照原有值算
        10M bit/s = 128k byte/s * 10 = 1280K byte/s = (1280/1024)M byte/s = 1.25M byte/s
        
        
#### 云服务器
    (CUP核数)核 (内存)G (带宽)M
    1核2G 2M带宽：适用于一天几百上千的访问，大概1秒3-10人同时访问进活动。
    
    2核4G 5M带宽：适用于一天几万的访问，大概1秒10-50人同时访问进活动。
    
    8核16G 10M带宽：适用于一天几十万的访问，大概1秒100-500人同时访问进活动
    
#### I/O多路复用机制
    I/O多路复用 : 每个进程/线程同时处理 多个连接(I/O多路复用)
    利用epoll来实现IO多路复用,将连接信息和事件放到队列中,依次放到文件事件分派器,事件分派器将事件分发给事件处理器.
    
    c10k：https://www.jianshu.com/p/ba7fa25d3590
    
    用户A-Z   ->   I/O多路复用(s0,s1,s2,s3)  -依次放到-> 文件事件分派器 -> 事件处理器(连接应答处理器1,连接应答处理器1...)

* c10k(一瞬间1w请求)
~~~
早期的一个TCP请求,就会创建一个进程(或线程),而进程属于操作系统,是非常昂贵的资源,并且有数量限制.
创建的进程线程多了,数据拷贝频繁（缓存I/O、内核将数据拷贝到用户进程空间、阻塞）, 进程/线程上下文切换消耗大, 导致操作系统崩溃,这就是C10K问题的本质！
~~~  
  
* 简单说下epoll(基于Linux)
~~~
支持一个进程打开大数目的socket描述符(fd)
只对发生变化的文件句柄感兴趣,工作机制类似于"事件"
通过 epoll_create 创建 epoll对象,
 linux内核会创建一个eventpoll结构体(
 重要的两个成员:
    红黑树的根节点: 这棵树中存储着所有添加到epoll中的事件，也就是这个epoll监控的事件。
    双向链表rdllist: 保存着将要通过epoll_wait返回给用户的、满足条件的事件。  
)
通过 epoll_ctl 注册文件描述符fd,一旦该fd就绪,
内核就会采用类似 callback 的回调机制来激活该fd, 
epoll_wait 便可以收到通知, 并通知应用程序.

|----------------------------------------------------------------------------------------------------------------
I/O多路复用(又被称为“事件驱动”)
one, two, ..., six 和 ser 进行聊天
1.逐个询问是否有聊天信息,如果 one 有,那 ser 处理 one 的信息,其它的就卡住.(阻塞)
2.ser 创建多个分身,即为每个用户创建个进程或者线程.(消耗过大)
3.one, two 主动告诉 ser 有信息, ser 依次进行处理, 然后等待其它人的通知.(非阻塞模式)

                                            tcp(ser)

one(fd)(client socket)  - 注册入epoll ->  建立callback event    ->  有变化(fd) -> epoll收到通知 -> 告诉tcp进行处理
two(fd)(client socket)  - 注册入epoll ->  建立callback event    ->  非阻塞 
six(fd)(client socket)  - 注册入epoll ->  建立callback event    ->  非阻塞
|---------------------------------------------------------------------------------------------------------------|
~~~