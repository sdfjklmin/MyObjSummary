## 缓存实现方案
缓存的实现主要分为两种，一种基于业务逻辑，另一种基于设计。相对来说业务逻辑比较强关联，这里主要介绍设计。

#### 1. 普通添加

针对自己的业务逻辑，在业务代码中添加缓存的获取或者修改。

#### 2. 全局模式

将 缓存命中和写入 应用到对应的 请求和响应之中。

TP 可以通过 Hook、行为、注册类 来进行统一入口，根据路由分发到对应的前置处理器。
这种方式可以不修改业务逻辑代码就可以实现。

其它框架可以根据对应的 行为、前置模块、AOP实现方式等。

#### 3. AOP 切面：基于动态代理

通过 AOP 的方式，将需要做缓存的业务切入的对应的缓存层。这里不需要修改自身业务逻辑就可以实现。

只需要配置对应业务代码的切入，或者 `注解`　等，都可以实现。

#### 4. 根据 log 来更新对应的缓存

当出现重复请求，频繁操作时。一般来说都是基于最终一致性为准。
二次或者三次提交过后，数据进入到对应的数据库，之后通过数据库的 binlog 来同步缓存数据。

这种方式需要实现 `缓存 + binlog` 之间的同步，无须修改业务代码，即可以同步变化的数据。

#### 5. 扩展对应框架的数据处理模型

扩展框架的 ORM 、数据处理，加入对应的缓存新增、修改或删除基类操作。
具体如何设计，可以根据自己的逻辑进行扩展。