## MySQL

##### 1.MySQL的复制原理以及流程
    (1) 主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；
    (2) 从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进 自己的relay log中；
    (3) 从：sql执行线程——执行relay log中的语句；
    
##### 2.MySQL中myisam与innodb的区别
    (1) 不同点；
        1>.InnoDB支持事物，而MyISAM不支持事物
        2>.InnoDB支持行级锁，而MyISAM支持表级锁
        3>.InnoDB支持MVCC(多版本并发控制), 而MyISAM不支持
        4>.InnoDB支持外键，而MyISAM不支持
        5>.InnoDB不支持全文索引，而MyISAM支持。
    (2) innodb引擎的4大特性
        插入缓冲（insert buffer),二次写(double write),自适应哈希索引(ahi),预读(read ahead)
    (3) 2者 select count(*)哪个更快，为什么
        myisam更快，因为myisam内部维护了一个计数器，可以直接调取。
        
##### 3.MySQL中varchar与char的区别以及varchar(50)中的50代表的涵义  
    (1) varchar与char的区别
        char是一种固定长度的类型，varchar则是一种可变长度的类型
    (2) varchar(50)中50的涵义
        最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)
    (3) int（20）中20的涵义
        是指显示字符的长度zerofill（零填充）
        但要加参数的，最大为255，比如它是记录行数的id,插入10笔资料，它就显示00000000001 ~~~00000000010，
        当字符的位数超过11,它也只显示11位，如果你没有加那个让它未满11位就前面加0的参数，它不会在前面加0
        20表示最大显示宽度为20，但仍占4字节存储，存储范围不变；
    (4) mysql为什么这么设计
        对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和int(20)存储和计算均一样；
        字节 ： tinyint(1)、smallint(2)、mediumint(3)、int(4)、bigint(8)
        
##### 4.Innodb的事务与日志的实现方式
    (1) 有多少种日志
            错误日志：记录出错信息，也记录一些警告信息或者正确的信息。
            查询日志：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。
            慢查询日志：设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。
            二进制日志：记录对数据库执行更改的所有操作。
            中继日志：
            事务日志：
    (2) 事物的4种隔离级别
            隔离级别
            读未提交(RU)
            读已提交(RC)
            可重复读(RR)
            串行
    (3) 事务是如何通过日志来实现的
            事务日志是通过redo和innodb的存储引擎日志缓冲（Innodb log buffer）来实现的，当开始一个事务的时候，会记录该事务的lsn(log sequence number)号;
            当事务执行时，会往InnoDB存储引擎的日志的日志缓存里面插入事务日志；
            当事务提交时，必须将存储引擎的日志缓冲写入磁盘（通过innodb_flush_log_at_trx_commit来控制），也就是写数据前，需要先写日志。这种方式称为“预写日志方式”
           
##### 5.MySQL binlog的几种日志录入格式以及区别
    (1) 每一条会修改数据的sql都会记录在binlog中。
        优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。(相比row能节约多少性能 与日志量，这个取决于应用的SQL情况，正常同一条记录修改或者插入row格式所产生的日志量还小于Statement产生的日志量，但是考虑到如果带条 件的update操作，以及整表删除，alter表等操作，ROW格式会产生大量日志，因此在考虑是否使用ROW格式日志时应该跟据应用的实际情况，其所 产生的日志量会增加多少，以及带来的IO性能问题。)
        缺点：由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的 一些相关信息，以保证所有语句能在slave得到和在master端执行时候相同 的结果。另外mysql 的复制,像一些特定函数功能，slave可与master上要保持一致会有很多相关问题(如sleep()函数， last_insert_id()，以及user-defined functions(udf)会出现问题).
        使用以下函数的语句也无法被复制：
        * LOAD_FILE()
        * UUID()
        * USER()
        * FOUND_ROWS()
        * SYSDATE() (除非启动时启用了 --sysdate-is-now 选项)
        同时在INSERT ...SELECT 会产生比 RBR 更多的行级锁
    (2) Row:不记录sql语句上下文相关信息，仅保存哪条记录被修改。
        优点： binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以rowlevel的日志内容会非常清楚的记录下 每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题
        缺点:所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容,比 如一条update语句，修改多条记录，则binlog中每一条修改都会有记录，这样造成binlog日志量会很大，特别是当执行alter table之类的语句的时候，由于表结构修改，每条记录都发生改变，那么该表每一条记录都会记录到日志中。
    (3) Mixedlevel: 是以上两种level的混合使用，一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则 采用row格式保存binlog,MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择 一种.新版本的MySQL中队row level模式也被做了优化，并不是所有的修改都会以row level来记录，像遇到表结构变更的时候就会以statement模式来记录。至于update或者delete等修改数据的语句，还是会记录所有行的 变更。

##### 6.MySQL数据库cpu飙升到500%的话他怎么处理？
    列出所有进程  show processlist  观察所有进程  多秒没有状态变化的(干掉)
    查看超时日志或者错误日志 (做了几年开发,一般会是查询以及大批量的插入会导致cpu与i/o上涨,,,,当然不排除网络状态突然断了,,导致一个请求服务器只接受到一半，比如where子句或分页子句没有发送,,当然的一次被坑经历)

##### 7.SQL优化
    (1) explain出来的各种item的意义；
        select_type 
        表示查询中每个select子句的类型
        type
        表示MySQL在表中找到所需行的方式，又称“访问类型”
        possible_keys 
        指出MySQL能使用哪个索引在表中找到行，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用
        key
        显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL
        key_len
        表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度
        ref
        表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值 
        Extra
        包含不适合在其他列中显示但十分重要的额外信息
    
    (2) profile的意义以及使用场景；
        查询到 SQL 会执行多少时间, 并看出 CPU/Memory 使用量, 执行过程中 Systemlock, Table lock 花多少时间等等

##### 8.备份计划，mysqldump以及xtranbackup的实现原理
    (1) 备份计划；
        这里每个公司都不一样，您别说那种1小时1全备什么的就行
    (2) 备份恢复时间；
        这里跟机器，尤其是硬盘的速率有关系，以下列举几个仅供参考
        20G的2分钟（mysqldump）
        80G的30分钟(mysqldump)
        111G的30分钟（mysqldump)
        288G的3小时（xtra)
        3T的4小时（xtra)
        逻辑导入时间一般是备份时间的5倍以上
    (3) xtrabackup实现原理
        在InnoDB内部会维护一个redo日志文件，我们也可以叫做事务日志文件。事务日志会存储每一个InnoDB表数据的记录修改。当InnoDB启动时，InnoDB会检查数据文件和事务日志，并执行两个步骤：它应用（前滚）已经提交的事务日志到数据文件，并将修改过但没有提交的数据进行回滚操作。

##### 9.mysqldump中备份出来的sql，如果我想sql文件中，一行只有一个insert....value()的话，怎么办？如果备份需要带上master的复制点信息怎么办？
    --skip-extended-insert
    [root@helei-zhuanshu ~]# mysqldump -uroot -p helei --skip-extended-insert
    Enter password:
      KEY `idx_c1` (`c1`),
      KEY `idx_c2` (`c2`)
    ) ENGINE=InnoDB AUTO_INCREMENT=51 DEFAULT CHARSET=latin1;
    /*!40101 SET character_set_client = @saved_cs_client */;
    
    --
    -- Dumping data for table `helei`
    --
    
    LOCK TABLES `helei` WRITE;
    /*!40000 ALTER TABLE `helei` DISABLE KEYS */;
    INSERT INTO `helei` VALUES (1,32,37,38,'2016-10-18 06:19:24','susususususususususususu');
    INSERT INTO `helei` VALUES (2,37,46,21,'2016-10-18 06:19:24','susususususu');
    INSERT INTO `helei` VALUES (3,21,5,14,'2016-10-18 06:19:24','susu');

##### 10.500台db，在最快时间之内重启
    puppet，dsh

##### 11.innodb的读写参数优化
    (1) 读取参数
        global buffer pool以及 local buffer；
    
    (2) 写入参数；
        innodb_flush_log_at_trx_commit
        innodb_buffer_pool_size
    
    (3) 与IO相关的参数；
        innodb_write_io_threads = 8
        innodb_read_io_threads = 8
        innodb_thread_concurrency = 0
    
    (4) 缓存参数以及缓存的适用场景。
        query cache/query_cache_type
        并不是所有表都适合使用query cache。造成query cache失效的原因主要是相应的table发生了变更
        第一个：读操作多的话看看比例，简单来说，如果是用户清单表，或者说是数据比例比较固定，比如说商品列表，是可以打开的，前提是这些库比较集中，数据库中的实务比较小。
        第二个：我们“行骗”的时候，比如说我们竞标的时候压测，把query cache打开，还是能收到qps激增的效果，当然前提示前端的连接池什么的都配置一样。大部分情况下如果写入的居多，访问量并不多，那么就不要打开，例如社交网站的，10%的人产生内容，其余的90%都在消费，打开还是效果很好的，但是你如果是qq消息，或者聊天，那就很要命。
        第三个：小网站或者没有高并发的无所谓，高并发下，会看到 很多 qcache 锁 等待，所以一般高并发下，不建议打开query cache


##### 12.你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？
    监控的工具有很多，例如zabbix，lepus，我这里用的是lepus

##### 13.你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？
    主从一致性校验有多种工具 例如checksum、mysqldiff、pt-table-checksum等

##### 14.你们数据库是否支持emoji表情，如果不支持，如何操作？
    如果是utf8字符集的话，需要升级至utf8_mb4方可支持
    之前的数据库字符集设计为 编码最大字符长度为3个字节（普通中文占两个字节，英文占一个字节，足够使用）
    utf8_mb4（most bytes 4） 内存为 4个字节，不排除以后还会增加新的字符集类型。

##### 15.你是如何维护数据库的数据字典的？
    这个大家维护的方法都不同，我一般是直接在生产库进行注释，利用工具导出成excel方便流通。

##### 16.你们是否有开发规范，如果有，如何执行的
    有，开发规范网上有很多了，可以自己看看总结下

##### 17.表中有大字段X(例如：text类型)，且字段X不会经常更新，以读为为主，请问:您是选择拆成子表，还是继续放一起，为什么？
    答：拆带来的问题：连接消耗 + 存储拆分空间；不拆可能带来的问题：查询性能；
    如果能容忍拆分带来的空间问题,拆的话最好和经常要查询的表的主键在物理结构上放置在一起(分区) 顺序IO,减少连接消耗,最后这是一个文本列再加上一个全文索引来尽量抵消连接消耗
    如果能容忍不拆分带来的查询性能损失的话:上面的方案在某个极致条件下肯定会出现问题,那么不拆就是最好的选择

##### 18.MySQL中InnoDB引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？
    答：InnoDB是基于索引来完成行锁
    例: select * from tab_with_index where id = 1 for update;
    for update 可以根据条件来完成行锁锁定,并且 id 是有索引键的列,
    如果 id 不是索引键那么InnoDB将完成表锁,,并发将无从谈起

##### 19.如何从mysqldump产生的全库备份中只恢复某一个库、某一张表？
    答案见：http://suifu.blog.51cto.com/9167728/1830651

##### 20.开放性问题一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。
    1、如果A表TID是自增长,并且是连续的,B表的ID为索引
    select * from a,b where a.tid = b.id and a.tid>500000 limit 200;
    
    2、如果A表的TID不是连续的,那么就需要使用覆盖索引.TID要么是主键,要么是辅助索引,B表ID也需要有索引。
    select * from b , (select tid from a limit 50000,200) a where b.id = a .tid;


##### 21.组合索引采用的是最左原则进行索引命中的。
    A、B、C为组合和索引，查询时 ABC生效，AC生效，BC不生效
    索引的劣势（虽然提示了查询速度但是也会降低更新表的速度，更新时会更新数据和保存索引文件，
    建立索引会占用磁盘空间的索引文件）
    
    索引是对数据库表中一列或多列的值进行排序的一种结构
    DB在执行一条Sql语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。
    如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度
 
##### 22.什么是索引 ？
    索引其实是一种数据结构，能够帮助我们快速的检索数据库中的数据
    
##### 23.索引具体采用的哪种数据结构？
    常见的MySQL主要有两种结构：Hash索引和B+ Tree索引，InnoDB引擎，默认的是B+树    
    
##### 24.InnoDB使用的B+ 树的索引模型，为什么采用B+ 树？这和Hash索引比较起来有什么优缺点吗？    
    (1) 因为Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，
        所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。
        所以，哈希索引只适用于等值查询的场景。
        而B+ 树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描
    (2) B+Tree索引和Hash索引区别在于
        哈希索引适合等值查询，但是无法进行范围查询
        哈希索引没办法利用索引完成排序
        哈希索引不支持多列联合索引的最左匹配规则
        如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在哈希碰撞问题

##### 25.1 B+ Tree的叶子节点都可以存哪些东西吗？        
    (1) InnoDB的B+ Tree可能存储的是整行数据，也有可能是主键的值   
##### 25.2 那这两者有什么区别吗 ？   (聚簇索引和非聚簇索引)
    在 InnoDB 里，索引B+ Tree的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引。而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引
##### 25.3 那么，聚簇索引和非聚簇索引，在查询数据的时候有区别吗？    
    聚簇索引查询会更快
    因为主键索引树的叶子节点直接就是我们要查询的整行数据了。
    而非主键索引的叶子节点是主键的值，查到主键的值以后，还需要再通过主键的值再进行一次查询
    主键索引查询只会查一次，而非主键索引需要回表查询多次（回表）。
##### 25.4  是所有情况都是这样的吗？非主键索引一定会查询多次吗？
    通过覆盖索引也可以只查询一次
##### 25.5 覆盖索引？
    覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。
    当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。
    如，表covering_index_sample中有一个普通索引 idx_key1_key2(key1,key2)。
    当我们通过SQL语句：select key2 from covering_index_sample where key1 = 'keytest';的时候，就可以通过覆盖索引查询，无需回表。
    
##### 26. 联合索引多个字段之间顺序你们是如何选择？
    把识别度最高的字段放到最前面 ？
    左前缀匹配吗 ？
    在创建多列索引时，根据业务需求，where子句中使用最频繁的一列放在最左边，因为MySQL索引查询会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。
    所以当我们创建一个联合索引的时候，如(key1,key2,key3)，相当于创建了（key1）、(key1,key2)和(key1,key2,key3)三个索引，这就是最左匹配原则
    
##### 27.索引下推、查询优化
    
    MySQL 5.6中，对索引做了哪些优化 ？

    Index Condition Pushdown（索引下推）
    MySQL 5.6引入了索引下推优化，默认开启，使用SET optimizer_switch = 'index_condition_pushdown=off';可以将其关闭。
    官方文档中给的例子和解释如下：
    people表中（zipcode，lastname，firstname）构成一个索引
    SELECT * FROM people WHERE zipcode='95054' AND lastname LIKE '%etrunia%' AND address LIKE '%Main Street%';
    如果没有使用索引下推技术，则MySQL会通过zipcode='95054'从存储引擎中查询对应的数据，返回到MySQL服务端，然后MySQL服务端基于lastname LIKE '%etrunia%'和address LIKE '%Main Street%'来判断数据是否符合条件。
    如果使用了索引下推技术，则MYSQL首先会返回符合zipcode='95054'的索引，然后根据lastname LIKE '%etrunia%'和address LIKE '%Main Street%'来判断索引是否符合条件。如果符合条件，则根据该索引来定位对应的数据，如果不符合，则直接reject掉。有了索引下推优化，可以在有like条件查询的情况下，减少回表次数。

##### 28. 索引生效，或者使用索引查询统计 ？
    可以通过explain查看sql语句的执行计划，通过执行计划来分析索引使用情况
    
##### 29. 什么情况下会发生明明创建了索引，但是执行的时候并没有通过索引呢 ？
    查询优化器 ？
    一条SQL语句的查询，可以有不同的执行方案，至于最终选择哪种方案，需要通过优化器进行选择，选择执行成本最低的方案。
    在一条单表查询语句真正执行之前，MySQL的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案。
    这个成本最低的方案就是所谓的执行计划。优化过程大致如下：
    1、根据搜索条件，找出所有可能使用的索引
    2、计算全表扫描的代价
    3、计算使用不同索引执行查询的代价
    4、对比各种执行方案的代价，找出成本最低的那一个
    
##### 30. 事务离级别 ？
    事务隔离级别(针对多个事务的数据处理)
    READ-UNCOMMITTED(读-未提交,有脏读) RU
      数据: name = test , A事务更新 name = test2,同时B事务也起了,B执行查询name = test2,
      若A回滚,实际数据为 name = test ,而B却返回了 name = test2 ,这就称之为脏读.
    READ-COMMITTED(读-已提交,不可重复读) RC
      一个事务只能读到另一个事务修改的已经提交了事务的数据
      A隐式提交了事务,B查询 name = test2,这是没有问题的,但B还没有结束,A中执行更新 name = test3,
      B执行查询 name = test3,这种称之为 不可重复读.
    REPEATABLE-READ(可重复读) RR
      一个事务只能读到另一个事务修改的已提交了事务的数据.
      但是第一次读取的数据，即使别的事务修改的这个值，
      这个事务再读取这条数据的时候还是和第一次获取的一样，不会随着别的事务的修改而改变
    SERIALIZABLE(串行化)
      只能进行读-读并发。只要有一个事务操作一条记录的写，那么其他要访问这条记录的事务都得等着
      一般没人用串行化，性能比较低，常用的是已提交读和可重复读。
      
##### 31.1 视图 ？
    是一种虚拟存在的表，视图可以理解为是一个容器，
	表通过条件查询之后，将查询后的结果放入这个容器内，
	然后给容器命名后即为视图。   

##### 31.2 视图相对于表的优势 ？
    简单，使用视图的用户不必关系后面的表，只需要使用过滤好的内容就行了；
    安全，因为对表的全新不能限制到表的行或者是列，所以可以通过视图来限制用户对表的访问权限；
    数据独立，确定了视图的结构之后，如果给原来的表增加了列，并不会影响视图，增加行，视图的相对于的行也会增加，如果源表的列名称发生了改变，可以通过修改视图来解决。
	
	表依赖修改视图也会修改，性能查询可能会慢特别是视图基于视图。
	
	
##### 32. Mysql读写性能是多少,有哪些性能相关的配置 ?
    读写性能可以根据压力测试来进行获取.
    相关配置:
        max_connecttions :	最大连接数
        table_cache		 :	缓存打开表的数量
        key_buffer_size	 :	索引缓存大小
        query_buffer_size:	查询缓存大小
        sort_buffer_size :	排序缓存大小
        read_buffer_size :	顺序读缓存大小
        具体查询配置:
            show variables like '%max_connecttions%'
##### 33. SQL层面已经难以优化,请求量还在增加的对应策略 ?
    分库分表
    使用集群(master-slave),读写分离
    增加业务层的cache层
    使用连接层
##### 34. 如何防止DB误操作和做好防灾 ?	
    重要DB数据的手工修改操作，操作前需做到2点：
        1.先在测试环境操作 
        2.备份数据:根据业务重要性做定时备份，考虑系统可承受的恢复时间
        进行容灾演练，感觉很必要
    MySql备份和恢复	
    
##### 35. MySql内部结构有哪些层次 ?
    Connectors：连接器。接收不同语言的Client交互
    Management Serveices & Utilities：系统管理和控制工具
    Connection Pool: 连接池。管理用户连接
    SQL Interface: SQL接口。接受用户的SQL命令，并且返回用户需要查询的结果
    Parser: 解析器。验证和解析SQL语句成内部数据结构
    Optimizer: 查询优化器。为查询语句选择合适的执行路径
    Cache和Buffer：查询缓存。缓存查询的结果，有命中即可直接返回
    Engine：存储引擎。MySQL数据最后组织并存储成具体文件	 	
    
##### 36. 针对InnoDB的机制，我们可以尝试几种优化方法:
    a.在session级别，提供可设置预读的触发条件，并使用多个后台线程来完成异步IO请求。因为没有减少小IO请求，作者尝试了这种方法，收益甚小；
    b.独立一个buffer pool，专门进行多块读，针对next extent，一次读取到buffer pool中，这种方式就和Oracle的multiblock-read比较类似了；
    c.终极优化方法，就是使用并行查询，Oracle在全表扫描的时候，使用/* parallel */ hint方法启动多个进程完成查询，InnoDB的聚簇索引结构，需要逻辑分片，针对每一个分片启动一个线程完成查询。
   