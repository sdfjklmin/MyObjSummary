#### 二叉树
        当数据量大的时候，树的高度会比较高，数据量大的时候，查询会比较慢；
        每个节点只存储一个记录，可能导致一次查询有很多次磁盘IO；
                    8
                   - - (这里始终是两个)
                  /   \ 
                 7     10
                - -    - -
               /  \   /   \  
              4   6  9    15
             
             
#### B树
      不再是二叉搜索，而是m叉搜索；
      叶子节点，非叶子节点，都存储数据；
      中序遍历，可以获得所有节点；
      非根节点包含的关键字个数j满足，(m/2)-1 <= j <= m-1，节点分裂时要满足这个条件。
      B树被作为实现索引的数据结构被创造出来，是因为它能够完美的利用“局部性原理”。            
             左边 <  15 < 右边
                    -- (这里是m叉) 
                  /    \
               (4  8)  (17 18 19 20) 这里有两个节点,可以存储更多记录,充分利用预读的特性,极大减少磁盘IO  
              ---(3叉)    ----(4叉)
             /   |   \ 
           1 3  4  7  10 14
             -  -  -
            /   \ /
           2    5 6 
          (这里5可以挂在4上,也可以挂在6上,这里有个红黑平衡树,如果将5挂在6上,但5没有子节点,它会自动往上与6平级)
      3.什么是局部性原理？
        局部性原理的逻辑是这样的：
        (1)内存读写快，磁盘读写慢，而且慢很多；
        (2)磁盘预读：磁盘读写并不是按需读取，而是按页预读，一次会读一页的数据，
            每次加载更多的数据，如果未来要读取的数据就在这一页中，可以避免未来的磁盘IO，提高效率；
            通常，一页数据是4K。
        (3)局部性原理：
            软件设计要尽量遵循“数据读取集中”与“使用到一个数据，大概率会使用其附近的数据”，
            
      4.B树为何适合做索引？
        (1)由于是m分叉的，高度能够大大降低；
        (2)每个节点可以存储j个记录，如果将节点大小设置为页大小，
            例如4K，能够充分的利用预读的特性，极大减少磁盘IO；
            这样磁盘预读能充分提高磁盘IO；
            
            
#### B+树
    仍是m叉搜索树，在B树的基础上，做了一些改进：

                         1 - 8
                          --- 
                    /      |      \
                  1  4     5      6 8
                   --      -       --
                   /\      |       /\
                 1 2 3 4   5      6 7 8    
                 1 ------链表----->>> 8
                     数据存储在叶子节点
                每个叶子节点到 '根' 的长度一致
                    
            (1)非叶子节点不再存储数据，数据只存储在同一层的叶子节点上；
                B+树中根到每一个节点的路径长度一样，而B树不是这样。
            (2)叶子之间，增加了链表，获取所有节点，不再需要中序遍历；
            (3)这些改进让B+树比B树有更优的特性：
                (1) 范围查找:
                        定位min与max之后，中间叶子节点，就是结果集，不用中序回溯；
                        范围查询在SQL中用得很多，这是B+树比B树最大的优势。
                (2) 存储:
                        叶子节点存储实际记录行，记录行相对比较紧密的存储，适合大数据量 '磁盘存储' ；
                        非叶子节点存储记录的PK，用于查询加速，适合 '内存存储' ；
                (3) 存储更多索引:
                        非叶子节点，不存储实际记录，而只存储记录的KEY的话，
                        那么在相同内存的情况下，B+树能够存储更多索引；
                    
      6.为什么m叉的B+树比二叉搜索树的高度大大大大降低？
            (1)局部性原理，将一个节点的大小设为一页，一页4K，假设一个KEY有8字节，一个节点可以存储500个KEY，即j=500
            (2)m叉树，大概m/2<= j <=m，即可以差不多是1000叉树
            (3)那么：
            一层树：1个节点，1*500个KEY，大小4K
            二层树：1000个节点，1000*500=50W个KEY，大小1000*4K=4M
            三层树：1000*1000个节点，1000*1000*500=5亿个KEY，大小1000*1000*4K=4G
            可以看到，存储大量的数据（5亿），并不需要太高树的深度（高度3），索引也不是太占内存（4G）。
      7. end
        数据库索引用于加速查询
        虽然哈希索引是O(1)，树索引是O(log(n))，但SQL有很多“有序”需求，故数据库使用树型索引
        InnoDB不支持哈希索引
        数据预读的思路是：磁盘读写并不是按需读取，而是按页预读，一次会读一页的数据，每次加载更多的数据，以便未来减少磁盘IO
        局部性原理：软件设计要尽量遵循“数据读取集中”与“使用到一个数据，大概率会使用其附近的数据”，这样磁盘预读能充分提高磁盘IO
        数据库的索引最常用B+树：
            (1)很适合磁盘存储，能够充分利用局部性原理，磁盘预读；
            (2)很低的树高度，能够存储大量数据；
            (3)索引本身占用的内存很小；
            (4)能够很好的支持单点查询，范围查询，有序性查询；            
       