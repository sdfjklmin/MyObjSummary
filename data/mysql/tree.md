#### 二叉树
        当数据量大的时候，树的高度会比较高，数据量大的时候，查询会比较慢；
        每个节点只存储一个记录，可能导致一次查询有很多次磁盘IO；
                    8
                   - - (这里始终是两个)
                  /   \ 
                 7     10
                - -    - -
               /  \   /   \  
              4   6  9    15
             
             
             
#### B树
      不再是二叉搜索，而是m叉搜索；
      叶子节点，非叶子节点，都存储数据；
      中序遍历，可以获得所有节点；
      非根节点包含的关键字个数j满足，(m/2)-1 <= j <= m-1，节点分裂时要满足这个条件。
      B树被作为实现索引的数据结构被创造出来，是因为它能够完美的利用“局部性原理”。            
             左边 <  15 < 右边
                    -- (这里是m叉) 
                  /    \
               (4  8)  (17 18 19 20) 这里有两个节点,可以存储更多记录,充分利用预读的特性,极大减少磁盘IO  
              ---(3叉)    ----(4叉)
             /   |   \ 
           1 3  4  7  10 14
             -  -  -
            /   \ /
           2    5 6 
          (这里5可以挂在4上,也可以挂在6上,这里有个红黑平衡树,如果将5挂在6上,但5没有子节点,它会自动往上与6平级)
      3.什么是局部性原理？
        局部性原理的逻辑是这样的：
        (1)内存读写快，磁盘读写慢，而且慢很多；
        (2)磁盘预读：磁盘读写并不是按需读取，而是按页预读，一次会读一页的数据，
            每次加载更多的数据，如果未来要读取的数据就在这一页中，可以避免未来的磁盘IO，提高效率；
            通常，一页数据是4K。
        (3)局部性原理：
            软件设计要尽量遵循“数据读取集中”与“使用到一个数据，大概率会使用其附近的数据”，
            
      4.B树为何适合做索引？
        (1)由于是m分叉的，高度能够大大降低；
        (2)每个节点可以存储j个记录，如果将节点大小设置为页大小，
            例如4K，能够充分的利用预读的特性，极大减少磁盘IO；
            这样磁盘预读能充分提高磁盘IO；
            
            
            
#### B+树
    仍是m叉搜索树，在B树的基础上，做了一些改进：

                         1 - 8
                          --- 
                    /      |      \
                  1  4     5      6 8
                   --      -       --
                   /\      |       /\
                 1 2 3 4   5      6 7 8    
                 1 ------链表----->>> 8
                     数据存储在叶子节点
                每个叶子节点到 '根' 的长度一致
                    
            (1)非叶子节点不再存储数据，数据只存储在同一层的叶子节点上；
                B+树中根到每一个节点的路径长度一样，而B树不是这样。
            (2)叶子之间，增加了链表，获取所有节点，不再需要中序遍历；
            (3)这些改进让B+树比B树有更优的特性：
                (1) 范围查找:
                        定位min与max之后，中间叶子节点，就是结果集，不用中序回溯；
                        范围查询在SQL中用得很多，这是B+树比B树最大的优势。
                (2) 存储:
                        叶子节点存储实际记录行，记录行相对比较紧密的存储，适合大数据量 '磁盘存储' ；
                        非叶子节点存储记录的PK，用于查询加速，适合 '内存存储' ；
                (3) 存储更多索引:
                        非叶子节点，不存储实际记录，而只存储记录的KEY的话，
                        那么在相同内存的情况下，B+树能够存储更多索引；
                    
      6.为什么m叉的B+树比二叉搜索树的高度大大大大降低？
            (1)局部性原理，将一个节点的大小设为一页，一页4K，假设一个KEY有8字节，一个节点可以存储500个KEY，即j=500
            (2)m叉树，大概m/2<= j <=m，即可以差不多是1000叉树
            (3)那么：
            一层树：1个节点，1*500个KEY，大小4K
            二层树：1000个节点，1000*500=50W个KEY，大小1000*4K=4M
            三层树：1000*1000个节点，1000*1000*500=5亿个KEY，大小1000*1000*4K=4G
            可以看到，存储大量的数据（5亿），并不需要太高树的深度（高度3），索引也不是太占内存（4G）。
      7. end
        数据库索引用于加速查询
        虽然哈希索引是O(1)，树索引是O(log(n))，但SQL有很多“有序”需求，故数据库使用树型索引
        InnoDB不支持哈希索引
        数据预读的思路是：磁盘读写并不是按需读取，而是按页预读，一次会读一页的数据，每次加载更多的数据，以便未来减少磁盘IO
        局部性原理：软件设计要尽量遵循“数据读取集中”与“使用到一个数据，大概率会使用其附近的数据”，这样磁盘预读能充分提高磁盘IO
        数据库的索引最常用B+树：
            (1)很适合磁盘存储，能够充分利用局部性原理，磁盘预读；
            (2)很低的树高度，能够存储大量数据；
            (3)索引本身占用的内存很小；
            (4)能够很好的支持单点查询，范围查询，有序性查询；            
       
       
#### DAT(double array trie)
    是 trie树 的一个变体优化数据结构，
    它在保证 trie树 检索效率的前提下，能大大减少内存的使用，经常用来解决检索，信息过滤等问题。
    
    trie树，又称单词查找树，是一种树形结构，是一种哈希树的变种。
    典型应用是用于统计，保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。
    它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。
    短文检索:
                       (/)
                   /    |    \
                  (a)  (b)   (c)
                 / | \        / \ 
              (n) (s) (t)    (n) (o) 
               /                   \ 
             (d)                    (m)
    例如：上面的 trie树 就能够表示｛and, as, at, cn, com｝这样5个标题的集合。
    用 trie树 ，数据会膨胀文档数*标题长度这么多，标题越长，文档数越多，内存占用越大。
    
    短文优化:“内存hash ＋ ID list”
        索引初始化步骤为：对所有标题进行分词，以词的hash为key，doc_id的集合为value
        查询的步骤为：对查询词进行分词，对分词进行hash，直接查询hash表格，获取doc_id的list，然后多个词进行合并
        
        例如：
            doc1 : 今天天气真好    =>  article id 1   => 更多内容
            doc2 : 今天要下雨      =>  article id 2   => 更多内容
            
        先标题进行分词：
            doc1 : 今天天气真好 -> 今天, 天气, 真好
            doc2 : 今天要下雨   -> 今天, 要, 下雨
            
        对分词进行hash，建立hash + ID list：
            hash(今天) -> {doc1, doc2}
            hash(天气) -> {doc1}
            hash(真好) -> {doc1}
            hash(要) -> {doc2}
            hash(下雨) -> {doc2}
        
        这样，所有标题的初始化就完毕了，你会发现，数据量和标题的长度没有关系。
        
        用户输入“今天天气”，分词后变为{今天，天气}，对各个分词的hash进行内存检索
           hash(今天)->{doc1, doc2}
           hash(天气)->{doc1}
        然后进行合并，得到最后的查找结果是doc1+doc2。
    
    存内存操作，能满足很大的并发，时延也很低，占用内存也不大，实现非常简单快速